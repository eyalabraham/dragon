#!/usr/bin/awk
#
# lst2h.awk
#
#   Convert as9 MC6809E assembler listing output to a header test file.
#   Write an assembly language program, assemble with as9, and convert
#   the produced .lst (listing) file to a header file.
#
#   To simplify processing of output:
#   Do not use ORG, will flag error. Manually change LOAD_ADDRESS and RUN_ADDRESS
#   Do not use RMB, FILL, or ZMB, will flag error
#
#   Usage: 
#          (1) as9 <asm-source> -l
#          (2) awk -f lst2h.awk <output-listing>.lst > <output-listing>.h
#

BEGIN   { printf("/********************************************************************\n");
          printf(" * .h\n");
          printf(" *\n");
          printf(" *  Auto-generated by lst2h.awk\n");
          printf(" *\n");
          printf(" *******************************************************************/\n\n");
          printf("#define     LOAD_ADDRESS    0x0000      // Change as required\n");
          printf("#define     RUN_ADDRESS     0x0000      // Change as required\n\n");
          printf("int code[] =\n");
          printf("{\n");

          FS = " ";
          IGNORECASE = 1;
          origin = 0;
          opcodes = "";
        }

//      { if ( FNR == 1 )
              printf("    /* Auto generated from %s\n     */\n", FILENAME);

          # Input sanity checks
          if ( match($0, "fill") || match ($0, "rmb") || match ($0, "zmb") || match ($0, "org") )
          {
              printf("    /* Aborted: FILL, ORG, ZMB, or RMB found in input line %d\n     */\n", NR);
              exit
          }
          
          # as9 listing file has a fixed column width format:
          # [line] [addr] [up to 6 bytes] [original source text ...]
          #
          # [line] four character + space, column 1..5
          # [addr] four characters + space, column 6..10
          # [bytes] 2 character + space per byte, columns 11..29
          # [source test] starting at column 30 to end of line
          #
          addr = substr($0, 6, 4);
          opcodes = substr($0, 11, 17);
          source = substr($0, 30);
          byte_count = split(opcodes, bytes);

          # Generate output lines
          byte_list = "";
          for (i = 1; i <= byte_count; i++)
              byte_list = sprintf("%s0x%s, ", byte_list, bytes[i]);

          printf("    %-36s// %s %s\n", byte_list, addr, source);
        }

END     { printf("   -1,                                  // --- end of code ---\n");
          printf("};\n");
        }
