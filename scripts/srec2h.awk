#!/usr/bin/awk
#
# srec2h.awk
#
#   Convert Motorola S-Record s19 memory image text file to a header test file.
#
#   *** SREC file should not have address gaps between records, i.e. multiple ORG directives.
#       Gaps between areas of code should be padded in the source and reassembled into SREC.
#
#   Usage: 
#          (1) awk -f srec2h.awk <output-srec-file>.hex > <output-listing>.h
#

BEGIN   { printf("/********************************************************************\n");
          printf(" * .h\n");
          printf(" *\n");
          printf(" *  Auto-generated by srec2h.awk\n");
          printf(" *\n");
          printf(" *******************************************************************/\n\n");
          printf("#define     LOAD_ADDRESS    0x0000      // ** Change required **\n");
          printf("#define     RUN_ADDRESS     0x0000      // Change as required\n\n");
          printf("int code[] =\n");
          printf("{\n");

          FS = " ";
          IGNORECASE = 1;
          origin = 0;
          opcodes = "";
        }

//      { if ( FNR == 1 )
          {
              printf("    /* Auto generated from %s\n     */\n", FILENAME);
              printf("    /* Start address for LOAD_ADDRESS is 0x%s\n     */\n", substr($0,5,4));
          }

          # Input sanity check to make sure records start with 'S' character
          if ( substr($0,1,1) != "S" )
          {
              printf("    /* Aborted: Bad start of record character found in input line %d\n     */\n", NR);
              exit;
          }

          # Convert S-REC record data into header file data format
          # Records have a fixed format
          # Source: https://en.wikipedia.org/wiki/SREC_(file_format)
          byte_count = hex2dec(substr($0,3,2));
          data_bytes = byte_count - 3;
          record_type = hex2dec(substr($0,2,1));

          # Only process simple records type 'S1' for data and
          # end processing if 'S9'
          if ( record_type == 9 )
          {
              exit;
          }
          else if ( record_type == 1 )
          {
              # Start the line checksum calculation
              checksum = 0;
              for ( i = 3; i < 9; i = i + 2)
              {
                  checksum = checksum + hex2dec(substr($0,i,2))
              }

              # Read data, check checksum, and output if valid
              byte_list = ""
              for ( i = 0; i < data_bytes; i++)
              {
                  byte_list = sprintf("%s0x%s, ", byte_list, substr($0,(9+2*i),2));
                  checksum = checksum + hex2dec(substr($0,(9+2*i),2));
              }

              # Compare check sum for validity
              record_checksum =  substr($0,(9+2*i),2);
              computed_checksum = compl1s(checksum);
              computed_checksum = substr(computed_checksum, length(computed_checksum)-1);

              #print "record_checksum " record_checksum;
              #print "computed_checksum " computed_checksum;

              if ( record_checksum != computed_checksum )
              {
                  printf("    /* Aborted: Bad record checksum found in input line %d\n     */\n", NR);
                  exit;
              }

              # Print output values
              printf("    %s\n", byte_list);
          }
          else
          {
              printf("    /* Aborted: Bad record type found in input line %d\n     */\n", NR);
              exit;
          }

        }

END     { printf("   -1,                                  // --- end of code ---\n");
          printf("};\n");
        }

#
# Convert input HEX number to decimal.
# Return a decimal number.
#
function hex2dec(hex_number)
{
    # The '+ 0' forces AWK to convert the string to a number
    return sprintf("%d", "0x" hex_number) + 0;
}

#
# Brute force 1's complement of a HEX number.
# Input in decimal notation.
# Returns a 1's complement (NOT) in HEX string notation
# with upper case digits.
#
function compl1s(number)
{
    hex_number = sprintf("%X", number);
#    print "compl1s()";
#    print "hex_number in "hex_number;

    compl_hex_number = "";

    for ( i = 1; i <= length(hex_number); i++ )
    {
        hex_digit = substr(hex_number,i,1)

        if ( hex_digit == "0" )
            compl_hex_number = compl_hex_number "F";
        else if ( hex_digit == "1" )
            compl_hex_number = compl_hex_number "E";
        else if ( hex_digit == "2" )
            compl_hex_number = compl_hex_number "D";
        else if ( hex_digit == "3" )
            compl_hex_number = compl_hex_number "C";
        else if ( hex_digit == "4" )
            compl_hex_number = compl_hex_number "B";
        else if ( hex_digit == "5" )
            compl_hex_number = compl_hex_number "A";
        else if ( hex_digit == "6" )
            compl_hex_number = compl_hex_number "9";
        else if ( hex_digit == "7" )
            compl_hex_number = compl_hex_number "8";
        else if ( hex_digit == "8" )
            compl_hex_number = compl_hex_number "7";
        else if ( hex_digit == "9" )
            compl_hex_number = compl_hex_number "6";
        else if ( hex_digit == "A" )
            compl_hex_number = compl_hex_number "5";
        else if ( hex_digit == "B" )
            compl_hex_number = compl_hex_number "4";
        else if ( hex_digit == "C" )
            compl_hex_number = compl_hex_number "3";
        else if ( hex_digit == "D" )
            compl_hex_number = compl_hex_number "2";
        else if ( hex_digit == "E" )
            compl_hex_number = compl_hex_number "1";
        else if ( hex_digit == "F" )
            compl_hex_number = compl_hex_number "0";
    }

#    print "hex_number out "compl_hex_number;

    return compl_hex_number;
}
