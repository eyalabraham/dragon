#!/usr/bin/awk
#
# hex2k.awk
#
#   Convert Intel HEX memory image text file to a header test file.
#
#   Usage: 
#          (1) awk -f hex2h.awk <output-HEX-fileg>.hex > <output-listing>.h
#

BEGIN   { printf("/********************************************************************\n");
          printf(" * .h\n");
          printf(" *\n");
          printf(" *  Auto-generated by hex2h.awk\n");
          printf(" *\n");
          printf(" *******************************************************************/\n\n");
          printf("#define     LOAD_ADDRESS    0x0000      // ** Change required **\n");
          printf("#define     RUN_ADDRESS     0x0000      // Change as required\n\n");
          printf("int code[] =\n");
          printf("{\n");

          FS = " ";
          IGNORECASE = 1;
          origin = 0;
          opcodes = "";
        }

//      { if ( FNR == 1 )
          {
              printf("    /* Auto generated from %s\n     */\n", FILENAME);
              printf("    /* Start address for LOAD_ADDRESS is 0x%s\n     */\n", substr($0,4,4));
          }

          # Input sanity check to make sure records start with ':' character
          if ( substr($0,1,1) != ":")
          {
              printf("    /* Aborted: Bad start of record character found in input line %d\n     */\n", NR);
              exit;
          }

          # Convert HEX record data into header file data format
          # Records have a fixed format
          # Source: https://en.wikipedia.org/wiki/Intel_HEX
          byte_count = hex2dec(substr($0,2,2));
          record_type = hex2dec(substr($0,8,2));

          # Only process simple records type '00' and '01'
          # End processing if '01', process like if '00'
          if ( record_type == 1 )
          {
              exit;
          }
          else if ( record_type == 0 )
          {
              # Start the line checksum calculation
              checksum = 0;
              for ( i = 2; i < 9; i = i + 2)
              {
                  checksum = checksum + hex2dec(substr($0,i,2))
              }

              # Read data, check checksum, and output if valid
              byte_list = ""
              for ( i = 0; i < byte_count; i++)
              {
                  byte_list = sprintf("%s0x%s, ", byte_list, substr($0,(10+2*i),2));
                  checksum = checksum + hex2dec(substr($0,(10+2*i),2));
              }

              # Compare check sum for validity
              file_checksum =  hex2dec(substr($0,(10+2*i),2));
              computed_checksum =  compl2s(checksum);

              #print "file_checksum " file_checksum;
              #print "computed_checksum " computed_checksum;

              if ( file_checksum != computed_checksum )
              {
                  printf("    /* Aborted: Bad record checksum found in input line %d\n     */\n", NR);
                  exit;
              }

              # Print output values
              printf("    %s\n", byte_list);
          }
          else
          {
              printf("    /* Aborted: Bad record type found in input line %d\n     */\n", NR);
              exit;
          }

        }

END     { printf("   -1,                                  // --- end of code ---\n");
          printf("};\n");
        }

#
# Convert input HEX number to decimal.
# Return a decimal number.
#
function hex2dec(hex_number)
{
    # The '+ 0' forces AWK to convert the string to a number
    return sprintf("%d", "0x" hex_number) + 0;
}

#
# Compute 2's complement of an input number.
# Brute force without depending on GAWK extensions.
# Input in decimal notation.
# Returns lower byte only of the input's 2's complement
# in decimal notation.
#
function compl2s(number)
{
#    print "compl2s"
    checksum_compl = ( "0x" compl1s(number)) + 1;
    checksum_compl = sprintf("%x", checksum_compl);
#    print number;
#    print checksum_compl;
    return hex2dec(substr(checksum_compl,length(checksum_compl)-1));
}

#
# Brute force 1's complement of a HEX number.
# Input in decimal notation.
# Returns a 1's complement (NOT) in HEX string notation
# with lower case digits.
#
function compl1s(number)
{
    hex_number = sprintf("%x", number);
#    print "compl1s()";
#    print "hex_number in "hex_number;

    compl_hex_number = "";

    for ( i = 1; i <= length(hex_number); i++ )
    {
        hex_digit = substr(hex_number,i,1)

        if ( hex_digit == "0" )
            compl_hex_number = compl_hex_number "f";
        else if ( hex_digit == "1" )
            compl_hex_number = compl_hex_number "e";
        else if ( hex_digit == "2" )
            compl_hex_number = compl_hex_number "d";
        else if ( hex_digit == "3" )
            compl_hex_number = compl_hex_number "c";
        else if ( hex_digit == "4" )
            compl_hex_number = compl_hex_number "b";
        else if ( hex_digit == "5" )
            compl_hex_number = compl_hex_number "a";
        else if ( hex_digit == "6" )
            compl_hex_number = compl_hex_number "9";
        else if ( hex_digit == "7" )
            compl_hex_number = compl_hex_number "8";
        else if ( hex_digit == "8" )
            compl_hex_number = compl_hex_number "7";
        else if ( hex_digit == "9" )
            compl_hex_number = compl_hex_number "6";
        else if ( hex_digit == "a" )
            compl_hex_number = compl_hex_number "5";
        else if ( hex_digit == "b" )
            compl_hex_number = compl_hex_number "4";
        else if ( hex_digit == "c" )
            compl_hex_number = compl_hex_number "3";
        else if ( hex_digit == "d" )
            compl_hex_number = compl_hex_number "2";
        else if ( hex_digit == "e" )
            compl_hex_number = compl_hex_number "1";
        else if ( hex_digit == "f" )
            compl_hex_number = compl_hex_number "0";
    }

#    print "hex_number out "compl_hex_number;

    return compl_hex_number;
}
